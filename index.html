<!DOCTYPE html>
<html lang="en">
<head>
	<meta charset="UTF-8">
	<title>JRPG Map Generator (Optimized)</title>
	<style type="text/css">
		body {
			font-family: Arial, sans-serif;
			background-color: #222;
			color: #fff;
		}
		canvas {
			image-rendering: pixelated;
			background-color: #000;
			border: 2px solid #555;
			margin-top: 10px;
		}
		#inputs {
			margin-bottom: 10px;
			padding: 10px;
			background-color: #333;
			border-radius: 5px;
			display: inline-block;
		}
		input {
			padding: 5px;
			margin-right: 5px;
			width: 80px;
		}
		button {
			padding: 5px 15px;
			cursor: pointer;
		}
		#statusMsg {
			margin-left: 15px;
			font-weight: bold;
			color: #4CAF50;
		}
	</style>
</head>
<body>

<div id="inputs">
	<label title="horizontal">W: <input type="number" id="horizontal" value="50" /></label>
	<label title="vertical">H: <input type="number" id="vertical" value="50" /></label>
	<label title="count of Islands">Islands: <input type="number" id="countOfIslands" value="50" /></label>
	<label title="MaxSize of dimension of island part">Max Size: <input type="number" id="MaxSize" value="5" /></label>
	<button id="generateBtn">Generate Map</button>
	<span id="statusMsg"></span>
</div>
<br/>
<div id="mapContainer"></div>

<script type="text/javascript">
	"use strict";

	// ==========================================
	// 1. IMAGE LOADING (PROMISES)
	// Eliminates the CPU-burning "while" loop
	// ==========================================
	const imageSources = {
		water: "water.png",
		land: "grass.png",
		grass: "grass.png",
		forest: "forest.png",
		mountain: "mountains.png",
		village: "village.png",
		fort: "fort.png",
		beach: "beach.png",
		desert: "desert.png",
		arctic: "snow.png",
		swamp: "swamp.png",
		steepe: "steepe.png",
		arcticForest: "forest snow.png",
		lakes: "lakes.png",
		town: "town.png",
		farm: "farm.png",
		desert_farm: "desert farm.png"
	};

	const IMAGES = {};
	let imagesLoaded = false;

	async function preloadImages() {
		const promises = Object.keys(imageSources).map(key => {
			return new Promise((resolve) => {
				const img = new Image();
				img.onload = () => { IMAGES[key] = img; resolve(); };
				img.onerror = () => {
					console.warn(`Could not load ${imageSources[key]}, creating fallback.`);
					// Create a tiny colored square if image is missing to prevent crashes
					const c = document.createElement('canvas');
					c.width = 10; c.height = 10;
					const ctx = c.getContext('2d');
					ctx.fillStyle = key === 'water' ? 'blue' : (key === 'grass' ? 'green' : 'gray');
					ctx.fillRect(0,0,10,10);
					IMAGES[key] = c;
					resolve();
				};
				img.src = imageSources[key];
			});
		});
		await Promise.all(promises);
		imagesLoaded = true;
	}

	// ==========================================
	// 2. HELPERS
	// ==========================================
	function plusminus() { return Math.random() < 0.5 ? -1 : 1; }
	
	// Yields to the browser to prevent UI freezing (The Loading Bar Fix)
	function yieldToBrowser() { return new Promise(r => setTimeout(r, 0)); }

	// ==========================================
	// 3. CORE LOGIC (FLYWEIGHT PATTERN)
	// Eliminates 250,000 sub-objects, saving Gigabytes of RAM
	// ==========================================
	class Tile {
		constructor(type, x, y) {
			this.type = type;
			this.x = x;
			this.y = y;
			this.biom = "regular";
		}
	}

	class Water extends Tile {
		constructor(x, y) { super("water", x, y); }
	}

	class Land extends Tile {
		constructor(x, y) {
			super("land", x, y);
			this.subtiles = []; // Stores primitive STRINGS instead of giant class instances
			
			for (let i = 0; i < 10; i++) {
				this.subtiles[i] = [];
				for(let j = 0; j < 10; j++) {
					this.subtiles[i][j] = "grass"; 
				}
			}
		}

		fill(subtileTypeStr, firstPoint, lastPoint, subtileContainer) {
			let firstX = Math.min(firstPoint.x, lastPoint.x);
			let lastX = Math.max(firstPoint.x, lastPoint.x);
			let firstY = Math.min(firstPoint.y, lastPoint.y);
			let lastY = Math.max(firstPoint.y, lastPoint.y);

			if (firstX < 0) firstX = 0;
			if (firstY < 0) firstY = 0;
			if (lastX > 9) lastX = 9;
			if (lastY > 9) lastY = 9;

			for (let i = firstX; i <= lastX; i++) {
				for (let j = firstY; j <= lastY; j++) {
					this.subtiles[i][j] = subtileTypeStr;
					if (subtileContainer) {
						subtileContainer.subtiles.push({x: i, y: j}); // Store coordinates, not objects!
					}
				}
			}
		}

		growForests() {
			for (let i = 0; i < this.parent.countOfForests; i++) {
				let forestCenter = {x: Math.ceil(Math.random()*10), y: Math.ceil(Math.random()*10)};
				let last = {x: forestCenter.x, y: forestCenter.y};
				let curr = {x:0, y:0};
				let currForest = {subtiles: []};
				
				for(let j = 0; j < this.parent.complexityOfForests; j++) {
					curr.x = last.x + Math.ceil(Math.random() * this.parent.sizeOfForests) * plusminus();
					curr.y = last.y + Math.ceil(Math.random() * this.parent.sizeOfForests) * plusminus();
					this.fill("forest", curr, last, currForest);
					last = {x: curr.x, y: curr.y};
					if (Math.random() < 0.5) last = {x: forestCenter.x, y: forestCenter.y};
				}
				this.parent.forests.push(currForest);
			}
		}

		growLakes() {
			for (let i = 0; i < this.parent.countOfLakes; i++) {
				let lakeCenter = {x: Math.ceil(Math.random()*10), y: Math.ceil(Math.random()*10)};
				let last = {x: lakeCenter.x, y: lakeCenter.y};
				let curr = {x:0, y:0};
				let currLake = {subtiles: []};
				
				for(let j = 0; j < this.parent.complexityOfLakes; j++) {
					curr.x = last.x + Math.ceil(Math.random() * this.parent.sizeOfLakes) * plusminus();
					curr.y = last.y + Math.ceil(Math.random() * this.parent.sizeOfLakes) * plusminus();
					this.fill("lakes", curr, last, currLake);
					last = {x: curr.x, y: curr.y};
					if (Math.random() < 0.2) last = {x: lakeCenter.x, y: lakeCenter.y};
				}
				this.parent.lakes.push(currLake);
			}
		}

		growMountains() {
			for (let i = 0; i < this.parent.countOfMountains; i++) {
				let mountainCenter = {x: Math.ceil(Math.random()*10), y: Math.ceil(Math.random()*10)};
				let last = {x: mountainCenter.x, y: mountainCenter.y};
				let curr = {x:0, y:0};
				let currMountain = {subtiles: []};
				
				for(let j = 0; j < this.parent.mountainComplexity; j++) {
					curr.x = last.x + Math.ceil(Math.random() * this.parent.mountainLength) * plusminus();
					curr.y = last.y + Math.ceil(Math.random() * this.parent.mountainLength) * plusminus();
					
					if (curr.x > curr.y) curr.y = Math.ceil(curr.y / this.parent.mountainDivider);
					else if (curr.x < curr.y) curr.x = Math.ceil(curr.x / this.parent.mountainDivider);
					else {
						curr.y = Math.ceil(curr.y / this.parent.mountainDivider);
						curr.x = Math.ceil(curr.x / this.parent.mountainDivider);
					}
					
					this.fill("mountain", curr, last, currMountain);
					last = {x: curr.x, y: curr.y};
				}
				this.parent.mountains.push(currMountain);
			}
		}

		growVillages() {
			let amount = Math.floor(Math.random() * this.parent.countOfVillages);
			for (let i = 0; i < amount; i++) {
				let currentVillage = {subtiles: []};
				let curr = {x: Math.floor(Math.random()*10), y: Math.floor(Math.random()*10)};
				let next = {
					x: Math.ceil(curr.x + plusminus() * Math.random() * this.parent.sizeOfVillages),
					y: Math.ceil(curr.y + plusminus() * Math.random() * this.parent.sizeOfVillages)
				};
				this.fill("village", curr, next, currentVillage);
				this.parent.villages.push(currentVillage);
			}
		}

		growFarms() {
			let amount = Math.floor(Math.random() * this.parent.countOfFarms);
			for (let i = 0; i < amount; i++) {
				let currentFarm = {subtiles: []};
				let curr = {x: Math.floor(Math.random()*10), y: Math.floor(Math.random()*10)};
				let next = {
					x: Math.ceil(curr.x + plusminus() * Math.random() * this.parent.sizeOfFarms),
					y: Math.ceil(curr.y + plusminus() * Math.random() * this.parent.sizeOfFarms)
				};
				this.fill("farm", curr, next, currentFarm);
				this.parent.farms.push(currentFarm);
			}
		}

		growBeaches(worldMap) {
			if(this.x !== 0 && worldMap.tiles[this.x - 1][this.y].type === "water") {
				let currBeach = {subtiles: []};
				this.fill("beach", {x:0, y:0}, {x:0, y:9}, currBeach);
				this.parent.beaches.push(currBeach);
			}
			if(this.x < worldMap.sizeX - 1 && worldMap.tiles[this.x + 1][this.y].type === "water") {
				let currBeach = {subtiles: []};
				this.fill("beach", {x:9, y:0}, {x:9, y:9}, currBeach);
				this.parent.beaches.push(currBeach);
			}
			if(this.y !== 0 && worldMap.tiles[this.x][this.y - 1].type === "water") {
				let currBeach = {subtiles: []};
				this.fill("beach", {x:0, y:0}, {x:9, y:0}, currBeach);
				this.parent.beaches.push(currBeach);
			}
			if(this.y < worldMap.sizeY - 1 && worldMap.tiles[this.x][this.y + 1].type === "water") {
				let currBeach = {subtiles: []};
				this.fill("beach", {x:0, y:9}, {x:9, y:9}, currBeach);
				this.parent.beaches.push(currBeach);
			}
		}

		growFort() {
			if (Math.random() < this.parent.fortChance) {
				let rx = Math.floor(Math.random()*10);
				let ry = Math.floor(Math.random()*10);
				this.subtiles[rx][ry] = "fort";
				this.parent.forts.push({subtiles: [{x: rx, y: ry}]});
			}
		}

		growTowns() {
			if (Math.random() < this.parent.townChance) {
				let rx = Math.floor(Math.random()*10);
				let ry = Math.floor(Math.random()*10);
				this.subtiles[rx][ry] = "town";
				this.parent.towns.push({subtiles: [{x: rx, y: ry}]});
			}
		}
	}

	class Island {
		constructor(parentWorld) {
			this.biom = "regular";
			this.lands = [];
			this.forests = [];
			this.mountains = [];
			this.villages = [];
			this.beaches = [];
			this.forts = [];
			this.lakes = [];
			this.farms = [];
			this.towns = [];
			
			this.parentWorld = parentWorld;
			
			this.countOfForests = Math.floor(Math.random()*10);
			this.sizeOfForests = Math.ceil(Math.random()*10);
			this.complexityOfForests = Math.ceil(Math.pow(this.countOfForests*this.sizeOfForests, 1/2));
			
			this.countOfMountains = Math.floor(Math.random()*3);
			this.mountainDivider = Math.ceil(Math.random()*30);
			this.mountainLength = Math.ceil(Math.random()*10);
			this.mountainComplexity = 1;
			
			this.countOfLakes = Math.floor(Math.random()*2);
			this.sizeOfLakes = Math.ceil(Math.random()*1);
			this.complexityOfLakes = Math.ceil(Math.pow(this.countOfLakes*this.sizeOfLakes, 1/2));
			
			this.countOfVillages = Math.floor(Math.random()*4);
			this.sizeOfVillages = Math.ceil(Math.random()*2);
			this.countOfFarms = Math.floor(Math.random()*4);
			this.sizeOfFarms = Math.ceil(Math.random()*2);
			
			this.townChance = this.countOfFarms / 10;
			this.fortChance = this.countOfVillages / 10;
		}

		chooseBiom() {
			this.biom = "regular";
			if (this.villages.length === 0) this.biom = "wildland";
			if (this.mountains.length === 0) this.biom = "swamp";
			if (this.forests.length === 0) {
				if (this.lands[0] && this.lands[0].y < this.parentWorld.sizeY * 8/10) {
					this.biom = "steepe";
				} else {
					this.biom = "desert";
				}
			}
			for (let i = 0; i < this.lands.length; i++) {
				this.lands[i].biom = this.biom;
			}
			if (this.lands[0] && this.lands[0].y < this.parentWorld.sizeY * 3/10) {
				this.biom = "arctic";
			}
		}
	}

	class WorldMap {
		constructor(sizeX, sizeY, countOfIslands, islandMaxSize, canvasElement) {
			this.sizeX = sizeX || 25;
			this.sizeY = sizeY || 25;
			this.countOfIslands = countOfIslands;
			this.islandMaxSize = islandMaxSize;
			this.canvas = canvasElement;
			this.ctx = canvasElement.getContext("2d", { alpha: false }); // Optimize rendering
			
			this.canvas.width = this.sizeX * 100;
			this.canvas.height = this.sizeY * 100;
			
			this.tiles = [];
			this.islands = [];
		}

		fill(firstPoint, lastPoint, island) {
			let firstX = Math.min(firstPoint.x, lastPoint.x);
			let lastX = Math.max(firstPoint.x, lastPoint.x);
			let firstY = Math.min(firstPoint.y, lastPoint.y);
			let lastY = Math.max(firstPoint.y, lastPoint.y);

			if (firstX < 0) firstX = 0;
			if (firstY < 0) firstY = 0;
			if (lastX > this.sizeX) lastX = this.sizeX;
			if (lastY > this.sizeY) lastY = this.sizeY;

			for (let i = firstX; i < lastX; i++) {
				for (let j = firstY; j < lastY; j++) {
					if (this.tiles[i][j].type !== "land") {
						this.tiles[i][j] = new Land(i, j);
					}
					island.lands.push(this.tiles[i][j]);
					this.tiles[i][j].parent = island;
				}
			}
		}

		async generate(statusElement) {
			// 1. Create Base Water
			statusElement.innerText = "Generating Base Map...";
			for (let i = 0; i < this.sizeX; i++) {
				this.tiles[i] = [];
				for(let j = 0; j < this.sizeY; j++) {
					this.tiles[i][j] = new Water(i, j);
				}
			}
			await yieldToBrowser();

			// 2. Grow Islands
			statusElement.innerText = "Growing Islands & Continents...";
			for (let i = 0; i < this.countOfIslands; i++) {
				let islandCenter = {x: Math.ceil(Math.random()*this.sizeX), y: Math.ceil(Math.random()*this.sizeY)};
				let last = {x: islandCenter.x, y: islandCenter.y};
				let islandComplexity = Math.pow(this.countOfIslands * this.islandMaxSize, 1/2);
				let curr = {x:0, y:0};
				let currIsland = new Island(this);
				
				for (let j = 0; j < islandComplexity; j++) {
					curr.x = last.x + Math.ceil(Math.random() * this.islandMaxSize) * plusminus();
					curr.y = last.y + Math.ceil(Math.random() * this.islandMaxSize) * plusminus();
					this.fill(curr, last, currIsland);
					last = {x: curr.x, y: curr.y};
					if (Math.random() < 0.5) last = {x: islandCenter.x, y: islandCenter.y};
				}
				if (currIsland.lands.length > 0) this.islands.push(currIsland);
				
				if (i % 5 === 0) await yieldToBrowser();
			}

			// 3. Populate Land Features
			statusElement.innerText = "Populating Forests, Lakes, and Mountains...";
			for (let i = 0; i < this.sizeX; i++) {
				for (let j = 0; j < this.sizeY; j++) {
					if (this.tiles[i][j].type === "land") {
						this.tiles[i][j].growBeaches(this);
						this.tiles[i][j].growLakes();
						this.tiles[i][j].growForests();
						this.tiles[i][j].growMountains();
						this.tiles[i][j].growVillages();
						this.tiles[i][j].growFarms();
						this.tiles[i][j].growTowns();
						this.tiles[i][j].growFort();
					}
				}
				if (i % 5 === 0) await yieldToBrowser();
			}

			// 4. Resolve Biomes
			for (let i = 0; i < this.islands.length; i++) {
				this.islands[i].chooseBiom();
			}

			// 5. Draw to Canvas Output
			statusElement.innerText = "Rendering final graphics...";
			await yieldToBrowser();
			this.render();
			
			statusElement.innerText = "Generation Complete!";
		}

		render() {
			this.ctx.fillStyle = "black";
			this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
			
			for (let i = 0; i < this.sizeX; i++) {
				for (let j = 0; j < this.sizeY; j++) {
					const tile = this.tiles[i][j];
					
					if (tile.type === "water") {
						for(let h=0; h<10; h++) {
							for(let v=0; v<10; v++) {
								if (IMAGES.water) this.ctx.drawImage(IMAGES.water, i*100 + h*10, j*100 + v*10, 10, 10);
							}
						}
					} else if (tile.type === "land") {
						let macroImgStr = "grass"; 
						if(tile.biom !== "regular" && tile.biom !== "wildland") {
							macroImgStr = tile.biom;
						}
						let macroImg = IMAGES[macroImgStr] || IMAGES.land;
						
						for(let h=0; h<10; h++){
							for(let v=0; v<10; v++){
								let subType = tile.subtiles[h][v];
								
								// 1. Draw base biome layer
								if(macroImg) this.ctx.drawImage(macroImg, i*100 + h*10, j*100 + v*10, 10, 10);
								
								// 2. Draw sub-element (if not basic grass)
								if(subType !== "grass" && IMAGES[subType]) {
									this.ctx.drawImage(IMAGES[subType], i*100 + h*10, j*100 + v*10, 10, 10);
								}
							}
						}
					}
				}
			}
		}
	}

	// ==========================================
	// 4. UI EVENT BINDING
	// ==========================================
	document.getElementById('generateBtn').addEventListener('click', async () => {
		const btn = document.getElementById('generateBtn');
		const status = document.getElementById('statusMsg');
		const container = document.getElementById('mapContainer');
		
		btn.disabled = true;

		// Load images only once
		if (!imagesLoaded) {
			status.innerText = "Loading Image Assets...";
			await preloadImages();
		}

		container.innerHTML = ""; // Clear old map
		const canvas = document.createElement('canvas');
		container.appendChild(canvas);

		const sizeX = parseInt(document.getElementById('horizontal').value, 10);
		const sizeY = parseInt(document.getElementById('vertical').value, 10);
		const countOfIslands = parseInt(document.getElementById('countOfIslands').value, 10);
		const maxSize = parseInt(document.getElementById('MaxSize').value, 10);

		const map = new WorldMap(sizeX, sizeY, countOfIslands, maxSize, canvas);
		
		// Run Async Generation
		await map.generate(status);

		btn.disabled = false;
		
		// Optional: Clean up status message after 3 seconds
		setTimeout(() => { if (!btn.disabled) status.innerText = ""; }, 3000);
	});
</script>

</body>
</html>
